/* 

题目描述
    - 给你一个 <非严格递增排列> 的数组 nums ，请你 <原地> 删除重复出现的元素，使每个元素 <只出现一次> ，返回删除后数组的新长度。
    元素的 <相对顺序> 应该保持 <一致> 。然后返回 nums 中唯一元素的个数。
    - 考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，
    并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。返回 k 。

输入输出示例1
    输入：nums = [1,1,2]
    输出：2, nums = [1,2,_] (不需要考虑数组中超出新长度后面的元素)

输入输出示例2
    输入：nums = [0,0,1,1,1,2,2,3,3,4]
    输出：5, nums = [0,1,2,3,4] (不需要考虑数组中超出新长度后面的元素)

*/

/* 

快慢指针法：使用两个指针，一个慢指针（slow）和一个快指针（fast）。
    - 快指针用于遍历整个数组，慢指针用于记录新数组的位置。
    - 初始时，将慢指针放在位置 0，表示新数组的起始位置。
    - 遍历数组，如果当前元素和前一个不重复元素不同（慢指针指向的元素），则将当前元素复制到慢指针 +1 的位置，并移动慢指针。
    - 最终，慢指针的位置 +1 就是新数组的长度。
时间复杂度分析：时间复杂度为 O(n)，因为我们只需遍历数组一次，每个元素都只被处理一次。
空间复杂度分析：空间复杂度为 O(1)，这是因为我们没有使用任何额外的存储空间，所有的操作都是在原地进行的，即直接在输入数组上进行修改。

*/

/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function (nums) {
    if (!nums.length) {
        return 0;
    }

    let slow = 0; // 慢指针，指向快指针当前查找到的最新的不重复元素
    let fast = 1; // 快指针，从第二个元素开始遍历（因为第一个元素肯定是唯一的）

    // 快指针指向的元素与慢指针指向的元素进行比较，如不相同，则将快指针指向的元素复制到 slow + 1 的位置，并移动快指针和慢指针；
    // 否则，仅移动快指针
    while (fast < nums.length) {
        if (nums[fast] !== nums[slow]) {
            nums[++slow] = nums[fast];
        }
        fast++;
    }

    return slow + 1;
};